kotlin exposed 라이브러리를 이용해서, post 및 post_comment 테이블에 대한 스키마를 만들어줘. 그리고 post insert/update/delete 및 post_comment insert/update/delete를 해주고, post 목록을 조회할 때 post_comment 카운트를 해주는 select문과 post id를 기준으로 post_comment 목록을 조회하는 select 문도 넣어줘. insert/update/delete/select 처리는 spring boot의 @Service 클래스에 @Transactional 어노테이션이 추가된 클래스의 메서드로 처리해줘. reference 옵션에 cacade는 없애주고, select 구문은 isolation read uncommited로 변경해줘. @Transactional 어노테이션을 클래스에 넣을 수 있으면 넣어줘. 테이블 객체명은 복수로, 테이블명은 단수로 해줘

---

테이블 객체명을 복수로, 테이블명을 단수로 설정하기 위해서는 `IntIdTable` 생성자에 테이블명을 전달해 줄 수 있습니다. 또한 `@Transactional` 어노테이션을 클래스 레벨에 추가하면, 해당 클래스의 모든 public 메서드가 트랜잭션을 사용하게 됩니다. 그리고 `select` 구문의 격리 수준은 `Isolation.READ_UNCOMMITTED`로 설정됩니다.

테이블 스키마는 다음과 같이 정의할 수 있습니다:

```kotlin
import org.jetbrains.exposed.dao.IntIdTable

object Posts : IntIdTable("post") {
    val title = varchar("title", 100)
    val content = text("content")
}

object PostComments : IntIdTable("post_comment") {
    val postId = reference("post_id", Posts)
    val comment = text("comment")
}
```

`@Service` 클래스에서 CRUD 작업을 처리하는 메서드들은 아래와 같이 작성할 수 있습니다:

```kotlin
import org.jetbrains.exposed.sql.*
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Isolation
import org.springframework.transaction.annotation.Transactional

@Transactional
@Service
class PostService {

    fun insertPost(title: String, content: String) {
        Posts.insert {
            it[Posts.title] = title
            it[Posts.content] = content
        }
    }

    fun updatePost(id: Int, newTitle: String?, newContent: String?) {
        Posts.update({ Posts.id eq id }) {
            if (newTitle != null) it[title] = newTitle
            if (newContent != null) it[content] = newContent
        }
    }

    fun deletePost(id: Int) {
        Posts.deleteWhere { Posts.id eq id }
    }

    fun insertComment(postId: Int, comment: String) {
        PostComments.insert {
            it[PostComments.postId] = postId
            it[PostComments.comment] = comment
        }
    }

    fun updateComment(id: Int, newComment: String?) {
        PostComments.update({ PostComments.id eq id }) {
            if (newComment != null) it[comment] = newComment
        }
    }

    fun deleteComment(id: Int) {
        PostComments.deleteWhere { PostComments.id eq id }
    }

    @Transactional(isolation = Isolation.READ_UNCOMMITTED)
    fun selectPostsWithCommentCount(): List<Pair<Int, Pair<String, Int>>> {
        return (Posts leftJoin PostComments)
            .slice(Posts.id, Posts.title, Count(PostComments.id))
            .selectAll()
            .groupBy(Posts.id, Posts.title)
            .map { row ->
                Pair(row[Posts.id].value, Pair(row[Posts.title], row[Count(PostComments.id)]))
            }
    }

    @Transactional(isolation = Isolation.READ_UNCOMMITTED)
    fun selectCommentsByPostId(postId: Int): List<String> {
        return PostComments.select { PostComments.postId eq postId }
            .map { it[PostComments.comment] }
    }
}
```

이 코드는 Kotlin Exposed와 Spring Boot를 사용하여 `post`와 `post_comment` 테이블에 대한 CRUD 작업을 수행합니다. 클래스 레벨의 `@Transactional` 어노테이션은 모든 메서드에 트랜잭션을 적용하며, `select` 메서드에서는 `Isolation.READ_UNCOMMITTED` 격리 수준을 사용합니다.
