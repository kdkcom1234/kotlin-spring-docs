`Page` 객체를 생성하고 반환하기 위해 Spring Boot의 `PageImpl` 클래스를 사용할 수 있습니다. 또한, 페이징을 위한 `limit`, `offset`, 그리고 `count` 쿼리를 적용하겠습니다. 마지막으로, `post`의 `id` 값을 기준으로 역정렬하겠습니다.

아래는 해당 요구사항을 반영한 코드 예시입니다:

```kotlin
import org.jetbrains.exposed.sql.*
import org.springframework.data.domain.Page
import org.springframework.data.domain.PageImpl
import org.springframework.data.domain.PageRequest
import org.springframework.transaction.annotation.Transactional
import org.springframework.stereotype.Repository

@Repository
class PostRepository {

    @Transactional(isolation = Isolation.READ_UNCOMMITTED)
    fun selectPostsWithCommentCount(page: Int, size: Int): Page<Pair<Int, Pair<String, Int>>> {

        // Create a Pageable object
        val pageable = PageRequest.of(page, size)

        // Calculate the total count for all the posts
        val totalCountQuery = Posts.selectAll().count()

        // Create the paginated and sorted query
        val paginatedAndSortedQuery = (Posts leftJoin PostComments)
            .slice(Posts.id, Posts.title, Count(PostComments.id))
            .selectAll()
            .groupBy(Posts.id, Posts.title)
            .orderBy(Posts.id to SortOrder.DESC)
            .limit(size, offset = page * size)  // Set limit and offset

        // Execute the query and map the results
        val paginatedData = paginatedAndSortedQuery.map { row ->
            Pair(row[Posts.id].value, Pair(row[Posts.title], row[Count(PostComments.id)]))
        }

        // Create and return a Page object
        return PageImpl(paginatedData, pageable, totalCountQuery)
    }
}
```

이 코드에서 주의할 점:

1. `PageRequest.of(page, size)`를 사용하여 `Pageable` 객체를 생성합니다.
2. `Posts.selectAll().count()`를 사용하여 전체 게시물 수를 계산합니다.
3. `orderBy(Posts.id to SortOrder.DESC)`를 쿼리에 추가하여 `post`의 `id` 값으로 역정렬합니다.
4. `limit(size, offset = page * size)`를 사용하여 쿼리를 페이징 처리합니다.
5. `PageImpl`을 사용하여 `Page` 객체를 생성하고 반환합니다. 이 객체에는 페이징 데이터와 총 개수, 그리고 `Pageable` 정보가 포함됩니다.

이렇게 하면 페이징과 정렬이 적용된 `Page` 객체를 반환할 수 있습니다.
