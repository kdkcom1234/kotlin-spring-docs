kotlin exposed를 이용하여 아래의 스키마를 생성할 거야. cacade 옵션은 빼줘

---

user, order, orderItem, product, inventory

---

그리고, order, orderItem, inventory를 이용한 트랜잭션을 생성할거야. order, orderItem 추가가되고, inventory의 재고는 감소해야해.

---

다음으로, user_id를 필터로 order 데이터를 페이징하여 조회할 거야,

---

다음으로, order_id를 필터로 order_item 목록들을 조회할 거야. product 테이블과 join해줘

---

마지막으로 order 일자별로 order_item의 product_id와 product_name을 기준으로 order amount 합계를 계산해줘. sum, group by 등의 함수를 이용해주고

---

Spring boot의 datasource를 이용할 것이고, @Service @Transactional 어노테이션이 있는 클래스에 메서드를 작성할 거야, 서비스 클래스는 OrderService로 해줘. @Transaction어노테이션은 서비스 클래스에 넣어주고. transaction {} 구문은 빼도되, 스프링의 @Transactional 어노테이션을 사용할 거야

---

테이블 정의:

```kotlin
import org.jetbrains.exposed.dao.id.IntIdTable
import java.time.LocalDate

object Users : IntIdTable() {
    val name = varchar("name", 50)
}

object Orders : IntIdTable() {
    val userId = integer("user_id").references(Users.id)
    val date = date("date")
}

object OrderItems : IntIdTable() {
    val orderId = integer("order_id").references(Orders.id)
    val productId = integer("product_id").references(Products.id)
    val amount = integer("amount")
}

object Products : IntIdTable() {
    val name = varchar("name", 50)
}

object Inventory : IntIdTable() {
    val productId = integer("product_id").references(Products.id)
    val quantity = integer("quantity")
}
```

`OrderService` 클래스:

```kotlin
import org.jetbrains.exposed.sql.*
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import java.time.LocalDate

@Service
@Transactional
class OrderService {

    fun addOrder(userId: Int, productOrders: Map<Int, Int>) {
        val orderId = Orders.insertAndGetId {
            it[this.userId] = userId
            it[date] = LocalDate.now()
        }.value

        productOrders.forEach { (productId, amount) ->
            OrderItems.insert {
                it[this.orderId] = orderId
                it[this.productId] = productId
                it[this.amount] = amount
            }

            val currentQuantity = Inventory.select { Inventory.productId eq productId }
                                           .single()[Inventory.quantity]

            Inventory.update({ Inventory.productId eq productId }) {
                it[quantity] = currentQuantity - amount
            }
        }
    }

    fun getPagedOrdersByUserId(userId: Int, limit: Int, offset: Int): List<ResultRow> {
        return Orders.select { Orders.userId eq userId }
                     .orderBy(Orders.date to SortOrder.DESC)
                     .limit(limit, offset = offset)
                     .toList()
    }

    fun getOrderItemsByOrderId(orderId: Int): List<ResultRow> {
        return (OrderItems innerJoin Products)
            .select { OrderItems.orderId eq orderId }
            .toList()
    }

    fun calculateTotalAmountByDate(): List<ResultRow> {
        return (Orders innerJoin OrderItems innerJoin Products)
            .slice(Orders.date, Products.id, Products.name, sum(OrderItems.amount))
            .selectAll()
            .groupBy(Orders.date, Products.id, Products.name)
            .toList()
    }
}
```

이 코드 예시에서는 Spring Boot의 `@Transactional` 어노테이션을 클래스 레벨에 적용하여, 해당 클래스의 모든 public 메서드가 트랜잭션 범위 내에서 실행되도록 했습니다. 이 설정은 Exposed 라이브러리와 잘 통합됩니다.

주의: 이 코드는 예시 코드이므로 실제 프로덕션 환경에 사용하기 전에 추가적인 검증과 에러 처리가 필요할 수 있습니다.
